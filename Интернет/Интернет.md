
# Стек протоколов
### Канальный уровень
_протоколы: Ethernet, DSL, Wi-FI_

Представим 2 компьютера, находящихся рядом. Как нам передать что-нибудь с одного на другой? Их нужно чем-то соединить, например, проволокой: Есть 
напряжение, значит 1, нету - 0. Таким образом можно передавать биты информации. Именно битами оперирует канальный уровень. Вместо проволоки используются Ethernet кабеля, раньше использовался DSL
![](attachments/Diagram%203.svg)
Но прогресс не стоит на месте, появляется Wi-Fi, а вместе с ним и вопрос: если мне пришло какое-то сообщение, как понять, что оно адресовано именно мне? Для адресации на этом уровне используются MAC-адреса. По идее, у каждого сетевого устройства в мире(!) должен быть свой уникальный MAC адрес, на практике, это не совсем так. 

### Межсетевой уровень
_Протоколы: IP_

Все компьютеры в мире не могут быть соединены физически проводом или как-либо ещё, поэтому их объединяют в сети.
Представим 2 компьютера, находящиеся в 2-х разных сетях, как нам передать что-нибудь с одного на другой? 
![](attachments/Diagram%204.svg)

Для этого изобрели IP адреса и роутеры.  Чтобы послать пакет (межсетевой уровень оперирует пакетами) на компьютер 2, компьютер 1 посылает его на роутер, а тот уже разбирается что делать дальше.  Роутер 1, в свою очередь, тоже находится в сети - сеть 3, он пошлёт этот пакет на главный роутер, тот на роутер 2, после чего пакет попадет к получателю. 

Например, отследим путь от моего компьютера до гугла
![](attachments/Pasted%20image%2020221021205019.png)
Узлы в этом списке - это роутеры.
Обратите внимание, на то, что ответ от некоторых узлов мы не получили. Дело в тот, что межсетевой  уровень и протокол IP не гарантируют доставку пакета: он может просто не дойти до адресата и тут это считается нормальным. 
![](attachments/Pasted%20image%2020221022151947.png)
_Вот, например, из 20 отправленных тестовых пакетов дошли все 100%. В этот раз повезло. Вообще, часть может потеряться_

Эту проблему решают дальше.


### Транспортный уровень.
_Протоколы: TCP, UDP_

Представим 2 компьютера, на каждом из которых открыто по приложению чата.  Мы уже умеем отправлять пакет с одного на другой, однако, если бы я был приложением чата, мне бы хотелось:
- чтобы компьютер понял, что пришедший пакет - это сообщение для приложения чата, отдал его (пакет этот) куда надо, а не, например, приложению браузера, которое в этот момент также запущено на компьютере адресата и также ловит пакеты из сети.
- чтобы сообщение точно дошло до адресата

Для решение 1-й проблемы изобрели порты. Для того, чтобы передать сообщение (Транспортный уровень оперирует сообщениями)  используя один из протоколов транспортного уровня, придётся помимо IP адреса указать порт. 
![](attachments/Pasted%20image%2020221021213345.png)
То, что до двоеточия - адрес, после - порт.

Для решения 2-й проблемы используется протокол TCP.  Чтобы обеспечить гарантию доставки, TCP:
- устанавливает соединение
- во время обмена пакетами периодически уточняет, всё ли дошло из отправленного дошло, если нет - отправляет потерянные пакеты заново.
- закрывает соединение, когда вся информация отправлена.

Помимо TCP на этом уровне есть протокол UDP. Он работает практически также как IP, просто отправляет пакеты, без подтверждения, но в отличии от IP, указывает порт.

### Прикладной уровень
_Протоколы: HTTP, WebSockets, DNS, любые другие_

Представим 2 компьютера, на каждом из которых запущено приложения чата, в котором, помимо самого сообщения, мы хотим отображать ещё и имя отправителя. Эту логику (Прикладной уровень оперирует тем, чем нужно программисту: любыми объектами, файлами, и тд) мы будем реализовывать взаимодействие клиента и сервера на прикладном уровне. На основе протоколов TCP и UPD написано огромное количество других протоколов, в частности HTTP и WebSockets, которые мы рассмотрим подробнее. При желании, можно даже придумать свой протокол прикладного уровня, таким, например, занимаются игры, программы для звонков (например discord), умные устройства, и другие.

### Вот картинка с уровнями протоколов
![](attachments/Pasted%20image%2020221019033147.png)

# Адреса, домены, DNS
До этого мы говорили только об адресах - MAC и IP, однако когда вы идёте на какой-то сайт, вы вводите не IP адрес, а его название, например _test.ru/test.html, как так получается?

- Для этого существуют DNS сервера. У такого сервера можно спросить, какой адрес соответствует домену (название сайта). 
![](attachments/Diagram%206.svg)
- Может получиться, что DNS сервер не знает такого домена, тогда зайти на сайт не удастся. 
![](attachments/Pasted%20image%2020230723142745.png)
- В нашем случае всё прошло хорошо, DNS сервер вернул ip адрес: 164.5.87.12 (IP адрес можно использовать вместо домена даже в адресной строке: http://164.5.87.12/test.html)

- Теперь мы можем установить соединение с сервером, но что значит http:// и /test.html? Первая часть запроса (она называется схемой) http:// говорит браузеру, что запрос нужно отправлять используя протокол HTTP.

 - Что делать с /test.html разберутся на сервере.

# Протокол HTTP 

- Протокол HTTP работает в формате запрос - ответ. 
- Есть несколько типов запросов, мы будет использовать только GET и POST.  Есть еще другие типы, но их мы трогать не будем, так как используются они значительно реже. Обычно GET запрос используется для получения чего-либо с сервера и не меняет данные, POST используется для того, чтобы изменить какую-либо информацию

- Запрос в HTTP состоит из заголовков и тела. В заголовках передается различная служебная информация (Тип запроса, что делать с соединением, как читать то, что придёт в теле и тд). В теле запроса находится основная информация - то, что мы хотим передать на сервер. Это актуально только для POST запросов, которые используются для передачи информации на сервер. GET запросы обычно не имеют тела, только заголовки. 
- У ответа на запрос всегда есть код ответа - число, которое говорит о статусе запроса 
- Выглядит GET запрос примерно так:

``` 
GET /get HTTP/1.1  - строка стостояния (Метод, путь, версия)
Host: httpbin.org  - хедеры (в данном случае один)

(Пустая строка означает, что заголовки кончились, дальше будет тело запроса, если оно есть)
```

Ответ выглядит примерно так:
```http
HTTP/1.1 200 OK // строка состояния, 200 - код ответа
Date: Sun, 27 Nov 2022 15:42:49 GMT 
Content-Type: application/json 
Content-Length: 728 
Connection: keep-alive 
Server: gunicorn/19.9.0 
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

... тут тело ответа ...
```
коды ответа - очень важная штука, по ним можно понять, успешно ли выполнился запрос, местный аналог ошибок
схема тут такая:
- 200 - всё хорошо, ошибок нет
- 400 и 400+ (например, 404) - ошибка со стороны клиента, например не передан какой-то параметр, без которого запрос выполнить нельзя (как если бы вы вызвали функцию, но передав неправильные аргументы)
- 500 и 500+ - ошибка со стороны сервера 

### Параметры
Часто просто url'а запроса не достаточно, чтобы передать всю информацию, что нужна для обработки запроса. В таких случаях используются **HTTP параметры**. Они могут назваться как угодно, их значениями могут быть строки, числа, в некоторых случаях массивы (однако не для всех запросов это доступно). Если вам нужно передать какую-то сложную структуру, обычно её переводят в строку (процесс преобразования структуры в строку часто называют **сериализацией**, обратно - **десериализацией**)

Способ передачи параметров будет отличаться для разных запросов:
- в GET запросах параметры кодируются прямо в адресную строку (это накладывает ограничения на общий размер параметров, так как максимальная длина адреса - 2083 символа. Для тяжёлых запросов, передающих много информации нужно использовать POST запросы)
- в POST запросах параметры кодируются в тело запроса. Обычно для этого в формате JSON или url-encoded, form-data и другие (вам об этом думать не нужно, за вас это сделает браузер/библиотека, используемая для отправки запроса)


### HTTP запросы в браузере
Для разработчиков в браузере есть специальное окошко, которое открывается, если нажать **F12** или **Ctrl+Shift+I** 
Выглядит примерно так:
![](attachments/Pasted%20image%2020230723164623.png)
Сегодня нас интересует вкладка "сеть", в ней как раз можно найти запросы, которые выполняет браузер, чтобы показать то, что мы видим

- Под полем фильтр выбрано "Все" - это тип запроса, пока мы не знаем, какие они бывают, оставляем "Все"
- Список под "Название" - это отправленные запросы, каждый из них можно открыть
- Во вкладке "Заголовки" (Headers) можно найти основную информацию о запросе и ответе (код, заголовки, куки).
- Во вкладке "Предварительный просмотр" (Preview) можно найти распаршенное тело ответа, во вкладке "Ответ" - тело ответа в сыром виде
- Если у запроса было тело, его можно найти во вкладке "Полезная нагрузка" (Payload)
![](attachments/Pasted%20image%2020230723165303.png)

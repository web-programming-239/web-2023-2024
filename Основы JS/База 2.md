# Функции 

## Как и в других языках

Ключевое слово **function** позволяет объявить функцию

```js
function doSomething() {
    return undefined + null + NaN
}

doSomething() // ?
```

Функция всегда что-то возвращает, ключевое слово **return** явно указывает на возвращаемый объект.
 
```js
function test1(){
    console.log('*_*')
}

function test2(){
    return 
}

let t1 = test1() // ?
let t2 = test2() // ?
```

## Аргументы
Думаю для вас не будет сюрпризом, что в js функция может получать на вход аргументы.

```js
function virus(value){
    return value * NaN
}

virus({type: 'human'}) // ?
```

Аргументы функции перечисляются через запятую 

```js
function sum(arg1, arg2, arg3, arg4) {
    return arg1 + arg2 + arg3 + arg4
}

sum(1, 2, 3, 4) // 10
```

А что если, я не знаю сколько аргументов принимает функция.
Начнем с малого, допустим я знаю, что не больше 4.

```js
sum(1, 2) // ?
```

В JS можно задавать значение по умолчанию

```js
function sum(arg1 = 0, arg2 = 0, arg3 = 0, arg4 = 0) {
    return arg1 + arg2 + arg3 + arg4
}

sum(1, 2) // 3
sum(1, 2, 3, 4, 5, 6, 7, 8) // ?
```

Аргументом может быть сколько угодно, вопрос лишь в том сколько мы обработаем.
Как обработать все значения?

```js
function sum(...args){
    let s
    for(let arg of args)
        s += arg
    return s
}

sum(1,2)
sum(1,2,3,4,5,6,7,8,9,11)
sum(1)
sum() // ?
```

"**...**" - оператор расширения. Все параметры переданные функции, соберутся в массив, в данном примере **words**.
Рассмотрим другую функцию.

```js
function print(name1 = 'Улитка', name2 = 'Бармена', ...args){
    console.log(`${name1} спрашивает ${name2}`)
    for(let arg of args)
        console.log(arg)
}
```

Оператор расширения - последний аргумент функции!
Три заветные точечки умеют не только упаковывать аргументы в массив, но и распаковывать массив в перечисление
его элементов

```js
let array = [1, 2, 3, 4, 5, 6, 7]
sum(...array)
```
```js
let arr1 = [1, 2, 3]
let arr2 = [5, 6]
let arr3 = [8, 9, 10]

let arr4 = [...arr1, 4, ...arr2, 7, ...arr3]
```

В последней "редактуре" функции **sum**, мы объявили переменную **s**. Внутри функций и вправду можно объявлять 
переменные.

```js
function tax(name, dirtySalary){
    let soap = 0.001
    return {
        name: `Бедный ${name}`,
        netSalary: dirtySalary * soap
    }
}


tax('программист', 100000) // ?
```

Обратите внимание на переменную **soap**, она задается внутри функции **tax**. Что будет, если обратиться к ней, за 
пределами **tax**?

## Область видимости
Областью видимости в JavaScript называют часть программы, в пределах которой компьютер видит набор всех созданных
переменных, функций и других данных, и может к ним обратиться.

Базово разделить область видимости можно на глобальную и локальную. Глобальная – это область видимости сразу всей
программы. А локальная – область видимости каждой отдельной части кода в программе, например, внутри функции.

```js
let a = 1
function f(c){
    let b = 2
    console.log(a)
    return c
}
console.log(f())
console.log(c) // ?
console.log(b) // ?
```

Параметры функции и переменные, объявленные внутри нее, "видны" только в пределах самой функции.

```js
let a = 1
function f(){
    let a = 2
    console.log(a)
}
f()
console.log(a) 

// ?
```

## Тоже **object**

В JavaScript функции называются функциональными объектами, потому что они являются объектами. Как и объекты,
функции имеют свойства и методы, их можно хранить в переменной или массиве и передавать в качестве аргументов другим 
функциям.

```js
function whoIAm(name, a, b, c){
    return `Я просто ${name}.`
}

typeof whoIAm // ?
whoIAm.name // ?
whoIAm.length // ?

whoIAm.deadinside = {name: 'Паджик'}

whoIAm.deadinside // ?
```


```js
let whoIAm = function (name, a, b, c) {
    return `Я просто ${name}.`
}
```

Способ задания функции классическим образом называется - **Function Declaration**.

Способ через присваивание - **Function Expression**.

```js
// a1() ?
// a2() ?

let a1 = function (b) {return b}

// a1() ?
// a2() ?

function a2(b) {
    a3()
    function a3(){
        
    }
    return b
}

// a1() ?
// a2() ?
```

Почему **a2** ведет себя следующим образом?
Ответ на этот вопрос совсем не очевиден, но понятен, если понимать, что есть лексическое окружение в JS

## Замыкания

Разберем классический пример для JS

```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

counter() // ?
counter() // ?
```

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
Другими словами, замыкание даёт вам доступ к внешней функции из внутренней функции.
В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

## Стрелочные функции

В JS есть более удобная форма записи для **function expression** - так называемая *стрелочная функция* 
```js
function a(x) {
    return x**3
}
a = function (x) {return x**3}
a = (x) => { return x**3 }
a = (x) => x**3
a = x => x**3
```

Если стрелочная функция получает на вход только один аргумент, скобки можно опустить 

```js
let a = () => 5
let b = (x, y) => x*y*a()
let c = n => b(n, 2)

c(3) // ?
```


## Map

У массивов есть метод **map**.

```js
let arr = [2, 3, 4]
arr = arr.map(n => n**2)
console.log(arr) // [4, 9, 16]
```

Давайте напишем свой **map**

```js
function myMap(f, arr) {
    let newArr = []
    for (let i = 0; i < arr.length; i++)
        newArr[i] = f(arr[i])
    return newArr
}

let fun = x => x * x
let arr = [1,4,5]
console.log(arr.map(fun))
console.log(myMap(fun, arr))
```

**Map** можно использовать вместо **for**, и необязательно для изменения исходного массива

```js
let names = ['Эля', 'Матвей', 'Саша']
for (let i = 0; i < names.length; i++) {
    console.log(names[i])
}

names.map((name) => console.log(name))
```

Или так

```js
for(let i = 0; i < 10; i++)
    console.log('Это очень старая и мудрая пословица, гласит нам о том, что, чтобы что-то в' +
        ' этой жизни знать, обладать какими-то знаниями, нужно обязательно все повторять, а' +
        ' иначе со временем все то, что мы когда-то узнали, будет забыто нашими мозгами и канет в бездну бытия.')

(new Array(10)).map(() => console.log('ПОВТОРЕНИЕ - МАТЬ УЧЕНИЯ')) // что будет если не писать () =>
```



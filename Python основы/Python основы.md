Нетипизированность
```python
int a = 10 # неправильно
String b = "asd" # неправильно
a = 10
b = "asd"
# можно менять тип переменной
a = 10
a = "asd" # корректный код

# в новых версиях питона есть подобие типизации, однако пользоваться этим не обязательно
a: int = 10
def test(param: str) -> None
	print(param)
```

Отступы для обозначения блока
```python
if (a == "test") {
	print(10)
} # неправильно

if a == "test":
	print(10)
	b = ""
	if something:
		print(True) # тут уже 2 таба отступа

```

IFы
```python
if a:
	...
elif b:
	...
else:
	...

if a and b:
	...
if a or b:
	...
if not a:
	...
# && || ! тут не используют

```

None - ничего
```python
a = None # специальное значение, показывающее, что тут ничего нет
# местный аналог null`ов из других языков
```

Функции
```python
int test(int param):
	return param # неправильно

def test(param):
	print(param)
	return param

# перегрузок в питоне нет, зато есть значение по умолчанию
def test2(param="test"):
	print(param)

# вызов функции
test2("Hello") # напечатает Hello
test2() # напечатает test

# также можно передавать аргументы, указывая имя
def func(a=10, b="test"):
	print(a)
	print(b)

func(b="Hello") # выведет 10 а потом Hello
```

Циклы, последовательности, списки
```python
# циклы в питоне работают не так, как в других языках
# вместо изменения переменной и проверки выполнения условия, как это 
# происходит в Java, c++ и других языках
for (int i = 0; i < 10, i++) {}

# в питоне цикл - это всегда "пробегание" переменной по последовательности
for i in range(10):
	...

# range(10), или range(0, 10) - функция, по которой можно итерироваться
# итерабельный объект
# переменная i будет равна 0, 1, ... 9
# 10 НЕ ВХОДИТ в сгенерированную последовательность
```

```python
arr = [0, 1, 2, 3, 4] # это список(массив), в питоне зовётся List
# он также является итерабельным объектом
# поэтому можно сделать так:
for element in arr:
	print(element)
```

```python
a = 10
while a < 10:
	a += 1 # a++ в питоне НЕ БЫВАЕТ, только +=
	print(a)
```

```python
arr1 = [1, 2, 3] # просто список
arr2 = [1, "test", True] # всё в порядке питон нетипизированный, привыкайте
print(arr1[0]) # выведет 1, нумерация начинается с 0
print(arr2[-1]) # выведет True, отрицательный индекс - это номер с конца
print(arr2[-2]) # выведет test
print(arr1[0:2]) # 1, 2 так можно взять сразу кусок списка

len(arr1) # длина списка, в данном случае 3

if 1 in arr1: # проверка есть ли элемент в списке
	print(True) 
```
Словари (мапы)
```python
a = {"a": 1, 10: True} # нетипизированность moment
print(a['a']) # 1
print(a[10]) # True

a["other_key"] = 15
print(a["other_key"]) # думаю понятно, что выведет

print(a["test"]) # Такого ключа нет, так что лови KeyError и впредь будь осторожней!
# но есть решение: a.get(ключ)
print(a.get('a')) # 1
print(a.get("test")) # None
```

Импорты
```python
import random
print(random.randint(0, 10))
# или

from random import randint
randint(0, 10)

# свои файлы также можно импортировать
# file test
def test_func():
	print("test")

# другой файл
import test
test.test_func()
```

функция type
```python
# type(что-то) - возвращает тип объекта
type(1) # <class 'int'> - значит 1 - это int
type("test") # <class 'str'>
type([1, 2, 3]) # <class 'list'>
```

Приведение типов
```python
# приведение типов
a = int("10") # в a будет 10
type(a) # <class 'int'>

a = str(10)
type(a) # <class 'str'>

```

#### Питоновская магия (простые заклинания)

Кортежи (tuple)
```python
a = (1, 2) # почти как [1, 2], но кортеж нельзя менять
a[0] = 10 # ошибка
# TypeError: 'tuple' object does not support item assignment
a = 1, 2 # скобки можно не писать, а - всё ещё tuple
# можем проверить 
print(type(a)) # <class 'tuple'>

# зачем он нужен?
# например
a, b = (10, 15) # a = 10, b = 15, оба типа int

# или
def get_two_values():
	return (10, "test")

a, b = get_two_values() # a = 10, b = "test"

# или
a, b = b, a # теперь a = "test", b = 10
```

Нетипизированность (опять)
```python
a = 10
if a: # эво как, так ведь нельзя? 
	print(True) 
# оказывается можно
# питон сам попытается привести переменную a к bool
# питон считает, что 10 - это True

bool(1) # True
bool("test") # True
bool("") # False
bool(0) # False
bool(None) # False
bool([]) # False, [] - пустой список
bool(()) # False, здесь () - пустой кортеж

# Как это испоьзовать:
a = None
b = 10
c = a or b # c = 10
```

```python
print('a' + 'b') # выведет ab
# оперетор сложения, как и другие операторы в питоне, ведёт себя по-разному
# в зависимости от типов переданнх ему аргументов
# напрмер, для двух строк '+' просто склеит их

print([0, 1, 2] + [3, 4, 5]) # [0, 1, 2, 3, 4, 5]
# так можно склеить 2 списка

print(1 + '1') # а вот так питон уже не умеет
# непонятно, хотим мы получить на выходе '11' или 2
print(str(1) + '1') # надо так
print(1 + int('1')) # или так

print(True + 10) # 11, True питон считает равным 1, а False - 0
``` 

Фокусы со строками
```python
a = "test"

print(a[1]) # e
print(a[0:2]) # te, правая граница не включается
print(a[::-1]) # tset, не спрашивайте почему

# пока всё как в массивах, но есть один нюанс
a[1] = "z" # TypeError: 'str' object does not support item assignment
# так нельзя, строки в питоне неизменяемые

b = "Hello world"
print(b.split(" ")) # ["Hello", "world"]
msg = "message"

print(f"new msg: {message}") # если добавить f перед строкой, в {} можно писать выражения
```


#### Напоследок

Работа с файлами
```python
with open('file.txt') as f:
	print f.readlines() # список строк файла

with open('file.txt', "w") as f: # 2 аргумент - mode с которым откоется файл
# w - write, mode по умолчанию r - read, 
# есть и другие, но пока это нам не очень интересно
	f.write("test") # напишет в файл test 

```

Обработка исключений
```python
try:
	print(1 + '1') # выдаст ошибку
except TypeError as e:
	print("exception occurred") # поймели 
finally:
	print("but I got this")
```

Вывод полей объекта
```python
a = list()
dir(a) # выведет кучу всего: методы и поля объекта
# может понадобиться, если хотите посмотреть, что у объекта можно взять или вызвать
```

### Продвинутые темы

### Библиотеки
В питоне за библиотеки отвечает **pip**. **pip** - это программа, которая устанавливается вместе с самим питоном(если конкретнее, то его интерпретатором). Чтобы поставить библиотеку нужно выполнить в терминале команду:
```bash
pip install *название библиотеки*
```
### venv
**Venv** - сокращение от **Virtual environment** (**Виртуальное окружение**). Оно используется для того, чтобы отделять окружения разных проектов друг от друга (под окружением в данном случае имеется ввиду интерпретатор и установленные рядом с ним библиотеки). Например, у вас на компьютере есть несколько проектов на питоне, но они написаны под разные версии питона и имеют разные зависимости (зависимости - это библиотеки, необходимые для работы проекта). Чтобы не было путаницы, для каждого из этих проектов создается своё виртуальное окружение.
При создании нового проекта Pycharm предложит вам создать виртуальное окружение - **соглашайтесь**
![](attachments/Pasted%20image%2020231115152908.png)
Обратите внимание, что **pip привязан к виртуальному окружению**, если вы поставили библиотеку в одном проекте, **она не появится в другом**
### Декораторы:
Декоратор - это функция-обертка над другой функцией. Он принимает в качестве аргумента исходную функцию и возвращает новую, модифицированную.
```python
def my_decorator(func):
	def inner(arg1, arg2): # создаем новую, модифицированную функцию
		print(f"called with {arg1}, {arg2}")
		return func(arg1, arg2)
	return inner # возвращаем её


@my_decorator
def sum(a, b):
	return a + b

a = sum(10, 15) # called with 10, 15
print(a) # 25
```

`@` - это синтаксический сахар. Запись выше эквивалентна
```python
def _sum(a, b):
	return a + b

sum = my_decorator(_sum)
```

### Анонимные функции (lambda)
`lambda` - это сокращенный синтаксис объявления функции. функции `f` и `f2` будут работать одинаково
```python
def f(x, y):
	return x + y

f2 = lambda x, y: x + y
```
Это местный аналог стрелочной функции из js `(x, y) => x + y`, правда, если в js стрелочная функция могла состоять из множества строк `() => {*тут пишем что хотим*}`, в python это всегда одна строка, соответственно, возможности таких функций сильно ограничены



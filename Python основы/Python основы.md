## Нетипизированность в Python

Python — динамически типизированный язык программирования, что означает, что при объявлении переменной не нужно 
указывать её тип. Переменная может менять свой тип во время выполнения программы.

### Пример:
```python
a = 10  # Переменная 'a' — целое число
a = "Hello"  # Теперь 'a' — строка
```
В отличие от статически типизированных языков, например, Java, где тип переменной обязателен:
```java
int a = 10;  # В Java
a = "Hello";  # Ошибка! В Java тип переменной неизменен
```

### Подсказки типов (Аннотация типов) (Type hints) 
В современных версиях Python (начиная с 3.5) появились **подсказки типов**. Однако это лишь рекомендации для 
разработчиков и статического анализа кода, их использование не обязательно:
```python
a: int = 10  # Python позволяет нам указать тип, но это не является обязательным
def test(param: str) -> None:
    print(param)
```
Обратите внимание, что несмотря на использование подсказок типов, Python по-прежнему допускает использование переменных
любого типа.

## Отступы для обозначения блока кода

В Python важны **отступы**, которые служат для обозначения вложенности блоков кода, а не фигурные скобки, как в других 
языках программирования.

### Пример:
```python
if a == "test":
    print(10)
    if something:
        print(True)
```
Каждый уровень вложенности кода обозначается дополнительным отступом.

## Операторы IF

В Python используются стандартные операторы ветвления: `if`, `elif`, `else`. Для логических операций применяются
английские слова `and`, `or`, `not`, а не символы:
```python
if a:
    ...
elif b:
    ...
else:
    ...

if a and b:
    ...
if not a:
    ...
```
Здесь не используются символы `&&`, `||`, `!`, как в C-подобных языках.

## None — значение "ничего"
`None` в Python — это специальное значение, которое означает отсутствие данных:
```python
a = None  # Это аналог null в других языках
```

## Функции

Функции в Python создаются с помощью ключевого слова `def`:
```python
def test(param):
    print(param)
    return param

def test2(param="test"):
    print(param)

test2("Hello")  # Выведет Hello
test2()  # Выведет test
```

Также можно передавать аргументы по имени:
```python
def func(a=10, b="test"):
    print(a)
    print(b)

func(b="Hello")  # Выведет 10 и Hello
```

### Перегрузка функций (методов)

**Перегрузка функций** — это возможность создания нескольких функций с одним и тем же именем, но разными параметрами 
(типами или количеством аргументов). В Python **перегрузки нет**, в отличие от языков, таких как Java, где это 
распространённая практика.

### Пример перегрузки методов в Java:
В Java можно создавать несколько методов с одинаковым именем, но разными параметрами:
```java
class MyClass {
    // Перегруженный метод для целых чисел
    public int sum(int a, int b) {
        return a + b;
    }
    
    // Перегруженный метод для дробных чисел
    public double sum(double a, double b) {
        return a + b;
    }

    // Перегруженный метод с разным количеством аргументов
    public int sum(int a, int b, int c) {
        return a + b + c;
    }
}
```

### Пример использования:
```java
MyClass obj = new MyClass();
System.out.println(obj.sum(5, 3));        // Выведет 8 (int)
System.out.println(obj.sum(5.5, 3.3));    // Выведет 8.8 (double)
System.out.println(obj.sum(1, 2, 3));     // Выведет 6 (int)
```

### В Python перегрузки нет:
В Python нельзя создать несколько функций с одним именем и разными параметрами. Последняя объявленная функция будет 
перезаписывать предыдущую. Однако можно использовать **значения по умолчанию** или **аргументы произвольной длины**
для имитации перегрузки.

### Пример в Python:
```python
def sum_values(a, b, c=0):  # Третьему аргументу можно присвоить значение по умолчанию
    return a + b + c

print(sum_values(5, 3))      # Выведет 8
print(sum_values(5, 3, 1))   # Выведет 9
```

Python также позволяет использовать `*args` для передачи произвольного количества аргументов:
```python
def sum_values(*args):
    return sum(args)

print(sum_values(5, 3))       # Выведет 8
print(sum_values(1, 2, 3))    # Выведет 6
```

## Циклы, последовательности

В Python цикл `for` всегда итерирует по **последовательности**, такой как список, строка или итерабельный объект.

### Пример с `range()`:
```python
for i in range(10):
    print(i)  # Выведет числа от 0 до 9
```
Функция `range(10)` возвращает последовательность чисел от 0 до 9, не включая 10.

### Пример с массивом (списком):
```python
arr = [0, 1, 2, 3, 4]
for element in arr:
    print(element)
```

### Цикл while:
```python
a = 10
while a < 10:
    a += 1  # В Python нет операции a++, только a += 1
    print(a)
```


## Списки (List) в Python

**Списки** — это изменяемые последовательности, которые могут содержать элементы разных типов.

### Создание списка:
```python
arr = [1, 2, 3, 4, 5]  # Список целых чисел
mixed_list = [1, "Hello", True]  # Список с элементами разных типов
```

### Доступ к элементам списка:
Нумерация элементов начинается с **нуля**:
```python
print(arr[0])  # Выведет 1
print(mixed_list[-1])  # Выведет True, отрицательный индекс - доступ с конца списка
```

### Срезы:
С помощью срезов можно получить подсписок:
```python
print(arr[1:3])  # Выведет [2, 3], правая граница не включается
print(arr[:3])  # Выведет [1, 2, 3], все элементы до индекса 3 (не включая)
print(arr[2:])  # Выведет [3, 4, 5], начиная с 3-го элемента
```

### Операции со списками:
- **Добавление элементов** в конец списка с помощью метода `append()`:
  ```python
  arr.append(6)
  print(arr)  # [1, 2, 3, 4, 5, 6]
  ```

- **Удаление элемента** по значению с помощью метода `remove()`:
  ```python
  arr.remove(2)
  print(arr)  # [1, 3, 4, 5, 6]
  ```

- **Удаление элемента** по индексу с помощью метода `pop()`:
  ```python
  arr.pop(0)
  print(arr)  # [3, 4, 5, 6]
  ```

- **Длина списка**. Для получения количества элементов используется функция `len()`:
  ```python
  print(len(arr))  # Выведет 4
  ```

- **Сложение списков**:
  ```python
  x = [1, 2]
  y = [3, 4]
  print(x + y) # [1, 2, 3, 4]
  ```

- **Сортировка**:
  ```python
  sorted(a) # вернет новый список с отсортированными элементами
  
  a.sort() # отсортирует исходный список
  ```

### Перебор элементов списка:
Цикл `for` может итерировать по списку напрямую:
```python
for element in arr:
    print(element)
```

### Проверка наличия элемента в списке:
Можно использовать оператор `in`:
```python
if 3 in arr:
    print("Элемент найден")
```

### Генераторы списков:
Генераторы списков — это мощный инструмент для создания списков на основе существующих:
```python
squares = [x ** 2 for x in range(5)]
print(squares)  # [0, 1, 4, 9, 16]
```

## Словари (мапы)

В Python для хранения пар "ключ-значение" используются **словаря**:
```python
a = {"a": 1, 10: True}  # нетипизированность moment
print(a['a'])  # Выведет 1
print(a[10])  # Выведет True
print(a["test"])  # Такого ключа нет, так что лови KeyError и впредь будь осторожней!
```
Если ключа нет, можно использовать метод `get()` для безопасного доступа:
```python
print(a.get("test"))  # Вернет None, а не вызовет ошибку
```

Причем метод `get()` может принимать 2 аргумента

```python
a = {}
print(a.get('test', -1))  # Выведет -1
```

## Классы и Объекты

Python поддерживает объектно-ориентированное программирование (ООП), где код структурирован с помощью **классов** и **объектов**.
### Классы

Класс — это шаблон (схема), который используется для создания объектов. В Python классы объявляются с помощью ключевого слова `class`.

### Пример создания класса:
```python
class Dog:
    # Конструктор класса (специальный метод __init__)
    def __init__(self, name, breed):
        self.name = name  # Атрибут (переменная) класса
        self.breed = breed  # Ещё один атрибут класса
    
    # Метод класса
    def bark(self):
        print(f"{self.name} says woof!")

# Создание объекта (экземпляра класса)
my_dog = Dog("Buddy", "Golden Retriever")
my_dog.bark()  # Выведет: Buddy says woof!

```

Методы класса всегда принимают первым аргументом **self**. Это - объект, у которого вызывали метод

```python
dog1 = Dog("Buddy1", "Golden Retriever")
dog2 = Dog("Buddy2", "Golden Retriever")
dog1.bark() # тут внутри метода bark вместо self окажется объект, лежищий в переменной dog1
dog2.bark() # а тут - dog2
```

### Изменение атрибутов класса

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def meow(self):
        print(f"{self.name} says meow!")
    
    def rename(self, new_name):
        self.name = new_name

my_cat = Cat("Whiskers")
my_cat.meow()  # Выведет: Whiskers says meow!
my_cat.rename("Luna")
my_cat.meow()  # Выведет: Luna says meow!
```

## Наследование

В Python классы могут наследовать свойства и методы других классов. Это позволяет создать новый класс, основанный на другом классе, и при этом добавлять или переопределять функциональность.


```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound.")

class Dog(Animal):
    def speak(self):
        print(f"{self.name} says woof!")

class Cat(Animal):
    def speak(self):
        print(f"{self.name} says meow!")

dog = Dog("Buddy")
dog.speak()  # Выведет: Buddy says woof!

cat = Cat("Whiskers")
cat.speak()  # Выведет: Whiskers says meow!

```

### Вызов метода родительского класса:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound.")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Вызов конструктора родительского класса
        self.breed = breed

    def speak(self):
        super().speak()  # Вызов метода родительского класса
        print(f"{self.name} says woof!")

dog = Dog("Buddy", "Golden Retriever")
dog.speak()
# Выведет:
# Buddy makes a sound.
# Buddy says woof!
```

Если необходимо вызвать метод родительского класса, можно использовать функцию `super()`:
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound.")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Вызов конструктора родительского класса
        self.breed = breed

    def speak(self):
        super().speak()  # Вызов метода родительского класса
        print(f"{self.name} says woof!")

dog = Dog("Buddy", "Golden Retriever")
dog.speak()
# Выведет:
# Buddy makes a sound.
# Buddy says woof!
```
### Магические методы
В Python есть набор специальных методов, которые позволяют настраивать поведение объектов с разными встроенными в язык конструкциями. Эти методы не вызывают напрямую, их вызывает сам питон в определенных ситуациях

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
		# Этот метод будт вызыан при попытке привести объект к строке
        return f"{self.name}, {self.age} лет"

person = Person("Alice", 30)
print(person)  # Выведет: Alice, 30 лет
```

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
	    # Этот метод будт вызыан при попытке сложить 2 объекта
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Выведет: (4, 6)

```
## Импорты

Для использования внешних модулей и файлов в Python используется команда `import`:
```python
import random
print(random.randint(0, 10))

from random import randint
print(randint(0, 10))
```

Также можно импортировать функции из своих файлов:
```python
# В файле test.py
def test_func():
    print("test")

# В другом файле
import test
test.test_func()
```

## Функция `type()`

Функция `type()` возвращает тип объекта:
```python
print(type(1))  # <class 'int'>
print(type("test"))  # <class 'str'>
```

## Приведение типов

Python поддерживает явное приведение типов:
```python
a = int("10")  # Преобразует строку "10" в число 10
a = str(10)  # Преобразует число 10 в строку "10"
```

## Кортежи (tuples)

Кортежи — это неизменяемые последовательности:
```python
a = (1, 2)
a[0] = 10  # Ошибка! Кортежи нельзя изменять
```

## Фокусы со строками

Строки в Python неизменяемы, но с ними можно производить различные операции:
```python
a = "test"
print(a[::-1])  # Перевернет строку и выведет "tset"
```

Для работы со строками полезна функция `split()`:
```python
b = "Hello world"
print(b.split(" "))  # Разобьет строку на ["Hello", "world"]
```

## Работа с файлами

Для работы с файлами в Python используют конструкцию `with`:
```python
with open('file.txt') as f:
    print(f.readlines())  # Чтение файла построчно

with open('file.txt', "w") as f:
    f.write("test")  # Запись в файл
```

## Обработка исключений

В Python можно перехватывать исключения с помощью блока `try-except`:
```python
try:
    print(1 + '1')  # Ошибка!
except TypeError as e:
    print("Произошла ошибка") # поймали 
finally:
    print("Это выполнится в любом случае")
```


## Считывание данных с консоли

Для того чтобы считывать данные, вводимые пользователем с клавиатуры, в Python используется функция `input()`.

### Пример:
```python
name = input("Введите ваше имя: ")
print(f"Привет, {name}!")
```
По умолчанию, `input()` возвращает данные в виде строки (тип `str`), поэтому, если нужно получить число, 
потребуется явно преобразовать тип:

### Пример преобразования:
```python
age = int(input("Введите ваш возраст: "))
print(f"Через год вам будет {age + 1}.")
```

Если не выполнить приведение типа, программа будет работать с введёнными данными как со строкой.

### Множественное считывание:
Еси необходимо ввести несколько значений сразу, их можно разделить пробелом и воспользоваться функцией `split()`:
```python
numbers = input("Введите три числа через пробел: ").split()
print(numbers)  # Вернет список строк
```
Для преобразования списка строк в список чисел можно использовать **генератор списков**:
```python
numbers = [int(x) for x in input("Введите три числа: ").split()]
print(numbers)  # Список целых чисел
```

## Продвинутые темы

### Библиотеки
В питоне за библиотеки отвечает **pip** - программа, которая устанавливается вместе с самим питоном(если 
конкретнее, то его интерпретатором). Для того чтобы поставить библиотеку, нужно выполнить в терминале команду:
```bash
pip install *название библиотеки*
```
### venv
**Venv** - сокращение от **Virtual environment** (**Виртуальное окружение**). Оно используется для того, чтобы отделять 
окружения разных проектов друг от друга (под окружением в данном случае имеется ввиду интерпретатор и установленные
рядом с ним библиотеки). Например, у вас на компьютере есть несколько проектов на питоне, но они написаны под разные 
версии питона и имеют разные зависимости (зависимости - это библиотеки, необходимые для работы проекта). 
Чтобы не было путаницы, для каждого из этих проектов создается своё виртуальное окружение.
При создании нового проекта Pycharm предложит вам создать виртуальное окружение - **соглашайтесь**
![](attachments/Pasted%20image%2020231115152908.png)
Обратите внимание, что **pip привязан к виртуальному окружению**, если вы поставили библиотеку в одном проекте, в
**она не появится в другом**

https://timeweb.cloud/tutorials/python/kak-sozdat-virtualnoe-okruzhenie
### Декораторы:
Декоратор - это функция-обертка над другой функцией. Он принимает в качестве аргумента исходную функцию и возвращает
новую, модифицированную.
```python
def my_decorator(func):
	def inner(arg1, arg2): # создаем новую, модифицированную функцию
		print(f"called with {arg1}, {arg2}")
		return func(arg1, arg2)
	return inner # возвращаем её


@my_decorator
def sum(a, b):
	return a + b

a = sum(10, 15) # called with 10, 15
print(a) # 25
```

`@` - это синтаксический сахар. Запись выше эквивалентна
```python
def _sum(a, b):
	return a + b

sum = my_decorator(_sum)
```

### Анонимные функции (lambda)
`lambda` - это сокращенный синтаксис объявления функции. функции `f` и `f2` будут работать одинаково
```python
def f(x, y):
	return x + y

f2 = lambda x, y: x + y
```
Это местный аналог стрелочной функции из js `(x, y) => x + y`, правда, если в js 
стрелочная функция могла состоять из множества строк `() => {*тут пишем что хотим*}`, в 
python это всегда одна строка, соответственно, возможности таких функций сильно ограничены


